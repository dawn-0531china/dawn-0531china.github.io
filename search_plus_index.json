{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction "},"Chapter/MacOS下搭建Gitbook并通过Git推送部署.html":{"url":"Chapter/MacOS下搭建Gitbook并通过Git推送部署.html","title":"第一章：MacOS下搭建Gitbook并通过Git推送部署","keywords":"","body":"第一章：MacOS下搭建Gitbook并通过Git推送部署 "},"Chapter1/MacOS Node版本管理.html":{"url":"Chapter1/MacOS Node版本管理.html","title":"第一节：MacOS Node版本管理","keywords":"","body":"第一节：MacOS Node版本管理 1、brew的安装 # 安装brew /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" # 查看brew版本(用于检查brew是否安装成功) brew --version 2、通过brew安装nvm(node version manager) #安装nvm brew install nvm # 查看nvm版本 nvm --version 3、配置.bash_profil文件 # 打开bash_profile open ~/.bash_profile # 将下面配置拷贝到bash_profile文件 export NVM_DIR=\"$HOME/.nvm\" [ -s \"/usr/local/opt/nvm/nvm.sh\" ] && \\. \"/usr/local/opt/nvm/nvm.sh\" # This loads nvm [ -s \"/usr/local/opt/nvm/etc/bash_completion.d/nvm\" ] && \\. \"/usr/local/opt/nvm/etc/bash_completion.d/nvm\" # This loads nvm bash_completion #保存后执行指令 source ~/.bash_profile 4、通过nvm安装指定node版本 # 查看可使用的node版本 nvm ls-remote # 安装node指定版本 nvm install 10.21.0 # 使用指定版本 nvm use 10.21.0 # 设置每次启动终端使用版本 nvm alias default 20.1.0 "},"Chapter1/GitBook安装及使用.html":{"url":"Chapter1/GitBook安装及使用.html","title":"第二节：Gitbook安装及使用","keywords":"","body":"第二节：Gitbook安装及使用 1、Gitbook本地安装 1.1、安装node 由于Gitbook是基于node.js的，并且支持的node版本比较老，所以要安装指定版本的node。 MacOS Node版本管理 # 安装指定版本node nvm install *** 1.2、安装gitbook-cli工具 # 切换能够支持gitbook的node版本 nvm use 10.21.0 # 通过nmp安装gitboo-cli npm install -g gitbook-cli # 查看gitbook的版本，验证是否安装成功 gitbook --version 1.3、安装Typora 安装Typora用于编辑markdown Typora下载地址：https://www.typora.io/ 2、Gitbook本地使用 2.1、初始化gitbook 新建一个文件夹，cd到这个文件夹下，通过gitbook init命令进行初始化。 cd *** gitbook init 执行玩命令后，可在文件夹下看到两个文件： README.md —— 书籍的介绍写在这个文件里 SUMMARY.md —— 书籍的目录结构在这里配置 2.2、编辑SUMMARY.md 通过Typora编辑SUMMARY.md文件，结构如下： # 目录 - [前言](README.md) - [第一章](Chapter1/***.md) - [第1节：***](Chapter1/***.md) - [第2节：***](Chapter1/***.md) - [第3节：***](Chapter1/***.md) - [第4节：***](Chapter1/***.md) - [第二章](Chapter2/***.md) - [第三章](Chapter3/***.md) 2.3、本地部署 回到命令终端，重新执行gitbook init命令，GitBook 会查找 SUMMARY.md 文件中描述的目录和文件，如果没有则会将其创建。 执行 gitbook serve 命令，将其部署在本地，打开浏览器 访问：http://localhost:4000/，即可看到本地部署的 Gitbook（注：serve 命令可以指定端口 gitbook serve --port 2333） 执行 gitbook build 命令构建书籍，默认将生成的静态网站输出到 _book 目录。这一步也包含在 gitbook serve 里面（注：build 命令可以指定路径 gitbook build [书籍路径] [输出路径]，如果你想查看输出目录详细的记录，可使用 gitbook build ./ --log=debug --debug 来查看) 3、托管到Github Page 3.1、本地项目提交到Github 在GitHub上创建一个仓库，将本地文件夹通过git init命令初始化为git仓库，配置本地git仓库远端仓库为GitHub上创建的仓库。编辑.gitignore文件，忽略_book文件夹。 * 忽略_book文件夹 _book 然后将本地仓库推送到远端仓库。可以创建提交脚本，方便后续使用： #!/bin/bash # 解决使用git add命令时报错LF will be replaced by CRLF的问题 echo '执行命令：git config auto.crlf true\\n' git config auto.crlf true # 保存所有的修改 echo '执行命令：git add -A\\n' git add -A # 把修改的文件提交 echo \"执行命令：git commit -m 'update gitbook'\\n\" git commit -m 'update gitbook' # 将本地仓库推送至远程仓库 echo '执行命令：git push origin master\\n' git push origin master # 返回到上一次的工作目录 echo \"回到刚才工作目录\" cd - 3.2、将构建的书籍上传到GitHub的gh-pages分支 将构建出来的_book推送到gh-pages分支 #!/bin/bash # 构建Gitbook echo '执行命令：gitbook build .' gitbook build . # 进入生成的文件夹 echo \"执行命令：cd ./_book\\n\" cd ./_book # 初始化一个仓库，仅仅是做了一个初始化的操作，项目里的文件还没有被跟踪 echo \"执行命令：git init\\n\" git init # 解决使用git add命令时报错LF will be replaced by CRLF的问题 echo '执行命令：git config auto.crlf true\\n' git config auto.crlf true # 保存所有的修改 echo \"执行命令：git add -A\" git add -A # 把修改的文件提交 echo \"执行命令：commit -m 'deploy gitbook'\" git commit -m 'deploy gitbook' # 发布到 https://.github.io/, 注意替换仓库地址 echo \"执行命令：git push -f 仓库地址.git main:gh-pages\" git push -f 仓库地址.git main:gh-pages # 返回到上一次的工作目录 echo \"回到刚才工作目录\" cd - 执行成功后，打开 github 仓库，选择 branch 分支，会发现多了一个 gh-pages 分支，打开这个分之后，里面会有一个 index.html 文件，说明部署的代码上传成功了。 打开github仓库的setting，在Pages，在Build and deployment中选择部署分支为gh-pages，打开自己的GitHub Pages链接，就可以看到自己构建的书籍。 "},"Chapter/Xcode和iOS.html":{"url":"Chapter/Xcode和iOS.html","title":"第二章：Xcode和iOS","keywords":"","body":"第二章：Xcode和iOS "},"Chapter2/WKWebView的一些处理.html":{"url":"Chapter2/WKWebView的一些处理.html","title":"第一节：WKWebView的一些处理","keywords":"","body":"第一节：WKWebView的一些处理 1、Cookie设置 1.1、在请求实例中设置cookie extension URLRequest { mutating func setCookies(_ cookies: [String: Any]) { let cookieString = cookies.map { \"\\($0.key)=\\($0.value)\" }.joined(separator: \";\") setValue(cookieString, forHTTPHeaderField: \"Cookie\") } } 1.2、通过脚本设置cookie extension WKUserScript { convenience init(cookie key: String, value: Any) { let domin: String = \".***\" // ***为域名通用部分 let userScript = \"document.cookie = '\\(key)=\\(value);path=/;domain=\\(domin);expiresDate=\\(Date(timeIntervalSinceNow: 2629743))'\" self.init(source: userScript, injectionTime: .atDocumentStart, forMainFrameOnly: false) } } // 或 // 这种设置方式适合与webview已经加载完成，但是需要更新cookie的情况 func evaluateCookieJavaScript() { if let sid = NetworkingManager.manager.sid { let cookieString = \"document.cookie = 'sid=\\(sid);path=/;domain=.****;expiresDate=\\(Date(timeIntervalSinceNow: 2629743))'\" self.evaluateJavaScript(cookieString, completionHandler: nil) } } 1.3、通过WKWebsiteDataStore设置cookie extension HTTPCookie { convenience init?(name: String, value: String) { let domin: String = \".***\" let properties: [HTTPCookiePropertyKey : Any] = [HTTPCookiePropertyKey.domain: domin, HTTPCookiePropertyKey.path: \"/\", HTTPCookiePropertyKey.name: name, HTTPCookiePropertyKey.value: value, HTTPCookiePropertyKey.expires: Date(timeIntervalSinceNow: 2629743), HTTPCookiePropertyKey.version: 0, HTTPCookiePropertyKey(\"HttpOnly\"): false] self.init(properties: properties) } } let configuration = WKWebViewConfiguration() for element in cookies { if let cookie = HTTPCookie(name: element.key, value: element.value) { configuration.websiteDataStore.httpCookieStore.setCookie(cookie, completionHandler: nil) } } 2、WKWebView内自动播放音视频 let configuration = WKWebViewConfiguration() configuration.mediaTypesRequiringUserActionForPlayback = [] 3、webview 白屏解决 3.1、WKCompositingView 被收回导致白屏解决方案 // 这种情况一般出现在通过evaluateJavaScript调用前端方法刷新页面数据时 // 可在evaluateJavaScript方法调用后调用下面两种方案中的一种解决 // 调用webview的私有方法 #pragma clang diagnostic ignored \"-Wundeclared-selector\" #pragma clang diagnostic push if ([self respondsToSelector:@selector(_updateVisibleContentRects)]) { [self performSelector:@selector(_updateVisibleContentRects)]; } #pragma clang diagnostic pop // 或 webView.setNeedsLayout() 4、WKWebView设置自定义字体 一般加载本地HTML时，可以通过更改路径的方式设置自定义字体。 下述方案是将字体准换为base64字符串，通过脚本注入的方式，设置自定义字体。这种方式适合非本地网页。 extension WKUserScript { // fontPath：本地字体包路径 // fontName：字体名，非字体包名 convenience init?(fontPath: URL, fontName: String) { do { let data = try Data(contentsOf: fontPath) let base64 = data.base64EncodedString(options: []) let javascript = String(format: \"var boldcss = '@font-face { font-family: \\\"%@\\\"; font-display: block; src: url(data:font/ttf;base64,%@) format(\\\"truetype\\\"); }'; var body = document.getElementsByTagName('body')[0], style = document.createElement('style'); style.type = 'text/css'; style.innerHTML = boldcss; body.appendChild(style);\", fontName, base64, fontName) self.init(source: javascript, injectionTime: .atDocumentEnd, forMainFrameOnly: false) } catch { return nil } } } "},"Chapter2/SwiftLint使用说明.html":{"url":"Chapter2/SwiftLint使用说明.html","title":"第二节：SwiftLint使用说明","keywords":"","body":"第二节：SwiftLint使用说明 1、swiftlint介绍 SwiftLint 是一个用于强制检查 Swift 代码风格和规定的一个工具，基本上以 Ray Wenderlich's Swift 代码风格指南为基础。 SwiftLint Hook 了 Clang 和 SourceKit 从而能够使用 AST 来表示源代码文件的更多精确结果。 说明：由于一些规则无用或者时规则冲突，且有的规则设计到代码逻辑的改动，因此只选用了和风格相关联的36条规则，便于大家代码风格的统一。 2、swiftlint 配置 使用pods安装： pod 'SwiftLint' 在Build Phases中添加如下脚本： \"${PODS_ROOT}/SwiftLint/swiftlint\" 在工程更目录下添加.swiftlint.yml文件，可以通过command+shift+.查看隐藏文件。 SwiftLint配置规则： disabled_rules: 关闭某些默认开启的规则。 opt_in_rules: 一些规则是可选的。 only_rules: 不可以和 disabled_rules 或者 opt_in_rules 并列。类似一个白名单，只有在这个列表中的规则才是开启的。 代码中忽略某个规则： // swiftlint:disable operator_usage_whitespace 3、引入的规范 3.1、括号中间如果有大括号，括号和大括号间不应该有空格 swiftlint标识符：closure_brace 代码示例： [].map({ }) [].map( { } ) 不要写成下面形式： [].map( { }) [].map({ } ) 3.2、闭包参数应该和闭包开始大括号在同一行 swiftlint标识符：closure_parameter_position 代码示例： [1, 2].map { $0 + 1 } [1, 2].map { [weak self] number in number + 1 } 3.3、闭包表达式和大括号间应该有一个空格 swiftlint 标识符：closure_spacing 代码示例： [].map ({ $0.description }) 不要写成下面这种形式： [].filter({$0.contains(location)}) 3.4、指定类型时，冒号应该在标识符旁边，并且在字典文字中的键旁边，冒号后要有一个空格 swiftlint标识符：colon 参考示例链接：https://realm.github.io/SwiftLint/colon.html 示例代码： func foo(bar: [String: Int]) {} 3.5、任何逗号前不能有空格 swiftlint标识符：comma 示例代码： func abc(a: String, b: String) { } 3.6、建议在注释斜杠后至少留一个空格以进行评论 swiftlint标识符：comment_spacing 示例代码： // This is a comment /// Triple slash comment 3.7、控制语句条件不应将条件表达式放到括号中 if、for、guard、switch、while、catch 语句的条件表达式不应该放到括号中 swiftlint标识符：control_statement 示例代码： if (a || b) && (c || d) { 不要写成下面的风格： if ((a || b) && (c || d)) { 3.8、枚举参数不使用时，在枚举与关联值匹配时忽略参数 swiftlint标识符：empty_enum_arguments 示例代码： switch foo { case .bar(let x): break } // 或 switch foo { case .bar: break } 注意不要写成下述风格： switch foo { case .bar(_): break } // 或 switch foo { case .bar(): break } 3.9、使用尾随闭包时，要避免在方法调用后使用空括号 swiftlint标识符：empty_parentheses_with_trailing_closure 示例代码： [1, 2].map { $0 + 1 } // 或 [1, 2].map({ $0 + 1 }) // 或 [1, 2].map { number in number + 1 } 避免使用下述风格代码： [1, 2].map() { $0 + 1 } // 或 [1, 2].map() { number in number + 1 } 3.10、枚举存在类型时，需要明确给枚举分配值 swiftlint标识符：explicit_enum_raw_value 示例代码： enum Numbers: Int { case one = 1 case two = 2 } 注意不要书写下述风格代码： enum Numbers: Int { case one = 10, two, three = 30 } 3.11、初始化时避免使用.init swiftlint标识符：explicit_init 示例代码： [1].flatMap(String.init) 避免使用下述风格代码： [1].flatMap{ String.init($0) } 3.12、避免隐式解包声明 swiftlint标识符：implicitly_unwrapped_optional 代码示例： let int: Int? = 42 避免下述代码： let int: Int! = 42 3.13、不要在方法名和括号中间添加空格 swiftlint标识符：no_space_in_method_call 代码示例： foo() 错误示例： foo () 3.14、大括号前应该有一个空格，并且和大括号在同一行 swiftlint标识符：opening_brace 示例代码： guard let a = b else { } 错误示例： guard let a = b else{ } 3.15、使用运算符时，运算符应该被一个空格包围 swiftlint标识符：operator_usage_whitespace 示例代码： let foo = 1 + 2 错误示例： let foo = 1+2 3.16、重载或定义运算符时，运算符应该被一个空格包围 swiftlint标识符：operator_whitespace 示例代码： func Int {} 错误示例： func Int {} 3.17、返回值箭头和返回值类型之间要有一个空格隔开或者单独一行隔开 swiftlint标识符：return_arrow_whitespace 示例代码： func abc() -> Int {} 错误示例： func abc()->Int {} 3.18、else或catch 应该和大括号在同一行，并且前后有一个空格 swiftlint标识符：statement_position 示例代码： } else if { 错误示例： }else if { 3.19、使用简单的语法糖声明类型 swiftlint标识符：syntactic_sugar 示例代码： let x: [Int] let x: [Int: String] let x: Int? 错误示例： let x: Array let x: Dictionary let x: Optional 3.20、避免在数组或者字典元素末尾使用逗号 swiftlint标识符：trailing_comma 示例代码： let foo = [1, 2, 3] 错误示例： let foo = [1, 2, 3,] 3.21、文件末尾有且仅有一个空行 swiftlint标识符：trailing_newline 示例代码： let a = 0 错误示例： let a = 0 3.22、语句结束末尾不要有分号 swiftlint标识符：trailing_semicolon 示例代码： let a = 0; let b = 0 错误示例： let a = 0; 3.23、类型名称应该只包含字母、数字，以大写字母开头，长度在3到40个字符之间 swiftlint标识符：type_name 示例代码： class MyType {} 错误示例： class myType {} 3.24、避免使用不必要的break语句 swiftlint标识符：unneeded_break_in_switch 示例代码： switch foo { case .bar: break } 错误示例： switch foo { case .bar: // something() break } 3.25、捕获列表中未使用的引用需要删除掉 swiftlint标识符：unused_capture_list 示例代码： [1, 2].map { [weak self] num in self?.handle(num) } 错误示例： [1, 2].map { [self] num in handle(num) } 3.26、不使用的闭包参数请求用_进行代替 swintlint标识符：unused_closure_parameter 示例代码： [1, 2].map { _ in 3 } 错误示例： [1, 2].map { number in return 3 // number } 3.27、声明的函数或变量至少应该被引用一次 swiftlint标识符：unused_declaration 示例代码： let kConstant = 0 _ = kConstant 3.28、不使用可选绑定时，请使用!= nil替代let _ = swiftlint标识符：unused_optional_binding 示例代码： if let bar = Foo.optionalValue { } 错误示例： if let _ = Foo.optionalValue { } 3.29、不要使用属性值给setter方法赋值 swiftlint标识符：unused_setter_value 示例代码： var aValue: String { get { return Persister.shared.aValue } set { Persister.shared.aValue = newValue } } 错误示例： var aValue: String { get { return Persister.shared.aValue } set { Persister.shared.aValue = aValue } } 3.30、声明函数时如果参数在多行，参数需要垂直对齐 swiftlint标识符：vertical_parameter_alignment 示例代码： func foo(a: Void, b: [String: String] = [:]) { } 错误示例： func foo(a: Void, b: [String: String] = [:]) { } 3.31、调用函数时，参数在多行，参数需要垂直对齐 swiftlint标识符：vertical_parameter_alignment_on_call 示例代码： foo(param1: 1, param2: bar param3: false, param4: true) 错误示例： foo(param1: 1, param2: bar param3: false, param4: true) 3.32、垂直空白符应限制在一个空行 swiftlint标识符：vertical_whitespace 示例代码： let a = 0 let b = 0 错误示例： let a = 0 let b = 0 3.33、关闭括号之前不要有空行 swiftlint标识符：vertical_whitespace_closing_braces 示例代码： [ 1, 2, 3 ] // 或 do { print(\"x is 5\") } 错误示例： [ 1, 2, 3 ] // 或 do { print(\"x is 5\") } 3.34、开始括号之后不要有空行 swiftlint标识符：vertical_whitespace_opening_braces 示例代码： [ 1, 2, 3 ] // 或 do { print(\"x is 5\") } 错误示例： [ 1, 2, 3 ] // 或 do { print(\"x is 5\") } 3.35、代理使用weak修饰 swiftlint标识符：weak_delegate 示例代码： class Foo { weak var delegate: SomeProtocol? } 错误示例： class Foo { var delegate: SomeProtocol? } 3.36、尤达条件规则 变量应该放在比较运算符的左边，常量放在比较运算符的右边。 swiftlint标识符：yoda_condition 示例代码： if foo == 42 {} 错误示例： if 42 == foo {} 4、参考 SwiftLint中文说明 SwiftLint Rule Directory Swift Style Guide "},"Chapter2/Xcode自定义环境配置.html":{"url":"Chapter2/Xcode自定义环境配置.html","title":"第三节：Xcode自定义环境配置","keywords":"","body":"第三节：Xcode自定义环境配置 1、配置Configurations 打开PROJECT工程，在Info下会看到Configurations选项。如下图： 默认情况下，项目会生成两种配置Debug和Release，开发时运行代码使用 Debug 配置，打包一般使用 Release配置，基于这两种配置我们可以做到的是基于当前环境(debug还是release)来设置不同的环境。 如：Spring环境根据debug和release可以设置对应的Debug_Test和Release_Test。 2、新增Scheme 首先我们项目默认只有一个Scheme，相应的Run和Archive操作也默认对应了Debug和Release环境。 我们新增两种环境后，首先想到的就是新增一个Scheme配置，然后将新增的Scheme的Run和Archive操作对应到我们新增的两种环境即可。如下图所示，我们新增了一个Scheme，然后修改了其Run/Archive操作到对应的Debug_Test和Release_Test环境。这样我们就可以通过两个Scheme来进行四种环境的操作了。 新增Scheme和编辑Scheme的时候记得勾选Shared。 3、定义User-defined setting 选中当前Target，在Build Settings栏点击+号，选择 Add-user-defined setting。 新增了一个名为APP_ENV_INFO的字段，然后在不同的环境下配置了相应的环境标识。 在info.plist中新增APP_ENV_INFO_KEY字段，将值设置成$(APP_ENV_INFO)。 4、获取环境 上述准备工作完成后，就可以通过设置的环境标识获取不同的环境。 static var isTest: Bool { guard let value = Bundle.main.object(forInfoDictionaryKey: \"APP_ENV_INFO_KEY\") as? String else { return false } return value == \"Test\" } "}}